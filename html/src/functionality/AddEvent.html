<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.functionality.AddEvent API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.functionality.AddEvent</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from src.functionality.shared_functions import add_event_to_file, turn_types_to_string, get_existing_types
from types import TracebackType
from src.Event import Event
from src.parse.match import parse_period
from src.functionality.create_event_type import create_event_type
from src.functionality.distance import get_distance
from datetime import datetime, timedelta
from src.parse.match import parse_period24
import discord

def check_complete(start, start_date, end, end_date, array):
    &#34;&#34;&#34;
    Function:
        check_complete
    Description:
        Boolean function to check if both the date objects are created
    Input:
        start_date - start date
        end_date - end date
    Output:
        - True if both the date objects are created else False
    &#34;&#34;&#34;
    if start and end:
        print(&#34;Both date objects created&#34;)
        array.append(start_date)
        array.append(end_date)
        return True
    else:
        return False


async def add_event(ctx, client):
    &#34;&#34;&#34;
    Function:
        add_event
    Description:
        Walks a user through the event creation process
    Input:
        ctx - Discord context window
        client - Discord bot user
    Output:
        - A new event added to the user&#39;s calendar file
        - A message sent to the context saying an event was successfully created
    &#34;&#34;&#34;

    channel = ctx.channel

    def check(m):
        return m.content is not None and m.channel == channel and m.author == ctx.author

    event_array = []
    await channel.send(&#34;Lets add an event!\n&#34; + &#34;First give me the name of your event:&#34;)
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    event_array.append(event_msg)
    await channel.send(
        &#34;Now give me the start &amp; end dates for you event. &#34;
        + &#34;You can use 12-hour formatting or 24-hour formatting\n\n&#34;
        + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
        + &#34;mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm (12-hour formatting)\n&#34;
        + &#34;Or mm/dd/yy hh:mm mm/dd/yy hh:mm (24-hour formatting)&#34;

    )

    event_dates = False
    # A loop that keeps running until a user enters correct start and end dates for their event following the required format
    # Adds start and end dates to the array if both are valid
    while not event_dates:
        date_array = []
        msg_content = &#34;&#34;
        start_complete = False
        end_complete = True
        if ctx.message.author != client.user:
            # Waits for user input
            event_msg = await client.wait_for(&#34;message&#34;, check=check)
            # Strips message to just the text the user entered
            msg_content = event_msg.content

        #print(&#34; yesa  &#34; + str(msg_content))
        if msg_content.__contains__(&#34;am&#34;) or msg_content.__contains__(&#34;pm&#34;) or msg_content.__contains__(&#34;AM&#34;) or msg_content.__contains__(&#34;PM&#34;):
            try:
                parse_result = parse_period(msg_content)
            except Exception as e:
                await channel.send(
                    &#34;Looks like &#34;
                    + str(e)
                    + &#34;. Please re-enter your dates.\n&#34;
                    + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
                    + &#34;mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm&#34;
                )
                start_complete = False
                continue

            start_complete = True

            #print(&#34;Lets see for 12 hr it now &#34; + str(parse_result))

            start_date = parse_result[0]
            end_date = parse_result[1]

            # If both datetime objects were successfully created, they get appended to the list and exits the while loop
            if not (event_dates := check_complete(start_complete, start_date, end_complete, end_date, event_array)):
                # If both objects were unsuccessfully created, the bot notifies the user and the loop starts again
                await channel.send(
                    &#34;Make sure you follow this format(Start is first, end is second): mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm&#34;
                )
                date_array = []
                msg_content = &#34;&#34;

        # 24hr format
        else:
            try:
                parse_result = parse_period24(msg_content)
            except Exception as e:
                await channel.send(
                    &#34;Looks like &#34;
                    + str(e)
                    + &#34;. Please re-enter your dates.\n&#34;
                    + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
                    + &#34;mm/dd/yy hh:mm mm/dd/yy hh:mm &#34;
                )
                start_complete = False
                continue

            start_complete = True

            #print(&#34;Lets see it now &#34; + str(parse_result))
            start_date = parse_result[0]
            end_date = parse_result[1]

            flag=0
            # If both datetime objects were successfully created, they get appended to the list and exits the while loop
            if not (event_dates := check_complete(start_complete, start_date, end_complete, end_date, event_array)):
                # If both objects were unsuccessfully created, the bot notifies the user and the loop starts again
                flag+=1
                if flag&gt;3:
                    await channel.send(
                    &#34;unable to create event due to incorrect time format&#34;
                )
                    return
                await channel.send(
                    &#34;Make sure you follow this format(Start is first, end is second): mm/dd/yy hh:mm mm/dd/yy hh:mm&#34;
                )
                date_array = []
                msg_content = &#34;&#34;

    # A loop to error check when user enters priority value
    event_priority_set = False
    while not event_priority_set:
        await channel.send(
            &#34;How important is this event? Enter a number between 1-5.\n\n&#34; +
            &#34;5 - Highest priority.\n&#34; +
            &#34;4 - High priority.\n&#34; +
            &#34;3 - Medium priority.\n&#34; +
            &#34;2 - Low priority.\n&#34; +
            &#34;1 - Lowest priority.\n&#34;
        )

        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered

        try:
            if 1 &lt;= int(event_msg) &lt;= 5:
                event_array.append(event_msg)
                event_priority_set = True  # if entered value is in the range, loop exits
            else:
                await channel.send(
                    &#34;Please enter a number between 1-5\n&#34;)
        except:
            await channel.send(
                &#34;Please enter a number between 1-5\n&#34;)  # Handles when user enters non numeric entries
            continue

    # create_type_tree(str(ctx.author.id))
    output = turn_types_to_string(str(ctx.author.id))
    
    if len(output.strip()) != 0:
        await channel.send(
            &#34;Tell me what type of event this is. Here are a list of event types I currently know:\n&#34; + output
        )

        types_list = get_existing_types(str(ctx.author.id)) # get list of existing type events

        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered

        if event_msg in types_list:

            await channel.send(
                &#34;Do you want to update the preferred time range for this event type? (Yes/no)&#34;
            )

            # Infinite loop - breaks when user chooses the acceptable option
            while True:
                is_update_event = &#34;&#34;
                is_update_event = await client.wait_for(&#34;message&#34;, check=check)
                is_update_event = is_update_event.content

                if is_update_event.lower().strip() == &#34;no&#34;:
                    break
                
                if is_update_event.lower().strip() == &#34;yes&#34;:
                    await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine
                    break

                await channel.send( &#34;Your response must be either Yes or No \n&#34; +
                    &#34;Do you want to update the preferred time range for this event type? (Yes/no)&#34;
                    )
        else:
            # When user enters new event type
            await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine

    else:
        # When there are no existing event types
        await channel.send(
            &#34;Seems like you do not have any existing event types. What should be the name of the new type?:\n&#34;
        )
        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered
        await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine

    event_array.append(event_msg)

    await channel.send(
        &#34;What is the location of the event?(Type None for no location/online)&#34;
    )
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    event_array.append(event_msg)
    dest=event_msg
    print(dest)
    if event_msg !=&#39;None&#39;:
        await channel.send(
            &#34;Do you want to block travel time for this event?(Yes/No)&#34;
        )
        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        travel_flag = event_msg.content
        if travel_flag ==&#39;Yes&#39;:
            await channel.send(
                &#34;Enter exact string out of following modes:[DRIVING, WALKING, BICYCLING, TRANSIT])&#34;
            )
            event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
            mode = event_msg.content
            
            await channel.send(
                &#34;Enter source address&#34;
            )
            event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
            src = event_msg.content
            travel_time=get_distance(dest,src,mode)
            end=event_array[1]
            strt=(end-timedelta(seconds=travel_time))
            
            
            current = Event(&#34;Travel&#34;,strt, end, &#34;1&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;)
            await channel.send(&#34;Your Travel event was successfully created!&#34;)
            add_event_to_file(str(ctx.author.id), current)
            
            
    await channel.send(&#34;Any additional description you want me to add about the event? If not, enter &#39;done&#39;&#34;)
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    if event_msg.lower() == &#34;done&#34;:
        event_array.append(&#34;&#34;)
    else:
        event_array.append(event_msg)
    



    # Tries to create an Event object from the user input
    try:
        current = Event(event_array[0], event_array[1], event_array[2], event_array[3], event_array[4], event_array[6],event_array[5])

        &#34;&#34;&#34;
        Check if the command is called in the DM or in general channel
        If DMed then add event to the author
        else ask mentions and save the event to the corresponding author ids
        &#34;&#34;&#34;
        
        if isinstance(ctx.channel, discord.channel.DMChannel):
            add_event_to_file(str(ctx.author.id), current)

        else:
            await channel.send(&#34;Mention people&#34;)
            users = []
            mentioned_members = await client.wait_for(&#34;message&#34;, check=check)
            mentioned_members = mentioned_members.content

            for member in mentioned_members.split():
                member_id = member[2:-1]
                print(&#34;this is&#34;, member_id)
                user = discord.utils.find(lambda m : m.id == int(member_id), channel.members)
                users.append(user.id)
            print(users)

            for i in users:
                add_event_to_file(str(i), current)

        await channel.send(&#34;Your event was successfully created!&#34;)
    except Exception as e:
        # Outputs an error message if the event could not be created
        print(e)
        TracebackType.print_exc()
        await channel.send(
            &#34;There was an error creating your event. Make sure your formatting is correct and try creating the event again.&#34;
        )
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.functionality.AddEvent.add_event"><code class="name flex">
<span>async def <span class="ident">add_event</span></span>(<span>ctx, client)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="function">Function</h2>
<p>add_event</p>
<h2 id="description">Description</h2>
<p>Walks a user through the event creation process</p>
<h2 id="input">Input</h2>
<p>ctx - Discord context window
client - Discord bot user</p>
<h2 id="output">Output</h2>
<ul>
<li>A new event added to the user's calendar file</li>
<li>A message sent to the context saying an event was successfully created</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_event(ctx, client):
    &#34;&#34;&#34;
    Function:
        add_event
    Description:
        Walks a user through the event creation process
    Input:
        ctx - Discord context window
        client - Discord bot user
    Output:
        - A new event added to the user&#39;s calendar file
        - A message sent to the context saying an event was successfully created
    &#34;&#34;&#34;

    channel = ctx.channel

    def check(m):
        return m.content is not None and m.channel == channel and m.author == ctx.author

    event_array = []
    await channel.send(&#34;Lets add an event!\n&#34; + &#34;First give me the name of your event:&#34;)
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    event_array.append(event_msg)
    await channel.send(
        &#34;Now give me the start &amp; end dates for you event. &#34;
        + &#34;You can use 12-hour formatting or 24-hour formatting\n\n&#34;
        + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
        + &#34;mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm (12-hour formatting)\n&#34;
        + &#34;Or mm/dd/yy hh:mm mm/dd/yy hh:mm (24-hour formatting)&#34;

    )

    event_dates = False
    # A loop that keeps running until a user enters correct start and end dates for their event following the required format
    # Adds start and end dates to the array if both are valid
    while not event_dates:
        date_array = []
        msg_content = &#34;&#34;
        start_complete = False
        end_complete = True
        if ctx.message.author != client.user:
            # Waits for user input
            event_msg = await client.wait_for(&#34;message&#34;, check=check)
            # Strips message to just the text the user entered
            msg_content = event_msg.content

        #print(&#34; yesa  &#34; + str(msg_content))
        if msg_content.__contains__(&#34;am&#34;) or msg_content.__contains__(&#34;pm&#34;) or msg_content.__contains__(&#34;AM&#34;) or msg_content.__contains__(&#34;PM&#34;):
            try:
                parse_result = parse_period(msg_content)
            except Exception as e:
                await channel.send(
                    &#34;Looks like &#34;
                    + str(e)
                    + &#34;. Please re-enter your dates.\n&#34;
                    + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
                    + &#34;mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm&#34;
                )
                start_complete = False
                continue

            start_complete = True

            #print(&#34;Lets see for 12 hr it now &#34; + str(parse_result))

            start_date = parse_result[0]
            end_date = parse_result[1]

            # If both datetime objects were successfully created, they get appended to the list and exits the while loop
            if not (event_dates := check_complete(start_complete, start_date, end_complete, end_date, event_array)):
                # If both objects were unsuccessfully created, the bot notifies the user and the loop starts again
                await channel.send(
                    &#34;Make sure you follow this format(Start is first, end is second): mm/dd/yy hh:mm am/pm mm/dd/yy hh:mm am/pm&#34;
                )
                date_array = []
                msg_content = &#34;&#34;

        # 24hr format
        else:
            try:
                parse_result = parse_period24(msg_content)
            except Exception as e:
                await channel.send(
                    &#34;Looks like &#34;
                    + str(e)
                    + &#34;. Please re-enter your dates.\n&#34;
                    + &#34;Here is the format you should follow (Start is first, end is second):\n&#34;
                    + &#34;mm/dd/yy hh:mm mm/dd/yy hh:mm &#34;
                )
                start_complete = False
                continue

            start_complete = True

            #print(&#34;Lets see it now &#34; + str(parse_result))
            start_date = parse_result[0]
            end_date = parse_result[1]

            flag=0
            # If both datetime objects were successfully created, they get appended to the list and exits the while loop
            if not (event_dates := check_complete(start_complete, start_date, end_complete, end_date, event_array)):
                # If both objects were unsuccessfully created, the bot notifies the user and the loop starts again
                flag+=1
                if flag&gt;3:
                    await channel.send(
                    &#34;unable to create event due to incorrect time format&#34;
                )
                    return
                await channel.send(
                    &#34;Make sure you follow this format(Start is first, end is second): mm/dd/yy hh:mm mm/dd/yy hh:mm&#34;
                )
                date_array = []
                msg_content = &#34;&#34;

    # A loop to error check when user enters priority value
    event_priority_set = False
    while not event_priority_set:
        await channel.send(
            &#34;How important is this event? Enter a number between 1-5.\n\n&#34; +
            &#34;5 - Highest priority.\n&#34; +
            &#34;4 - High priority.\n&#34; +
            &#34;3 - Medium priority.\n&#34; +
            &#34;2 - Low priority.\n&#34; +
            &#34;1 - Lowest priority.\n&#34;
        )

        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered

        try:
            if 1 &lt;= int(event_msg) &lt;= 5:
                event_array.append(event_msg)
                event_priority_set = True  # if entered value is in the range, loop exits
            else:
                await channel.send(
                    &#34;Please enter a number between 1-5\n&#34;)
        except:
            await channel.send(
                &#34;Please enter a number between 1-5\n&#34;)  # Handles when user enters non numeric entries
            continue

    # create_type_tree(str(ctx.author.id))
    output = turn_types_to_string(str(ctx.author.id))
    
    if len(output.strip()) != 0:
        await channel.send(
            &#34;Tell me what type of event this is. Here are a list of event types I currently know:\n&#34; + output
        )

        types_list = get_existing_types(str(ctx.author.id)) # get list of existing type events

        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered

        if event_msg in types_list:

            await channel.send(
                &#34;Do you want to update the preferred time range for this event type? (Yes/no)&#34;
            )

            # Infinite loop - breaks when user chooses the acceptable option
            while True:
                is_update_event = &#34;&#34;
                is_update_event = await client.wait_for(&#34;message&#34;, check=check)
                is_update_event = is_update_event.content

                if is_update_event.lower().strip() == &#34;no&#34;:
                    break
                
                if is_update_event.lower().strip() == &#34;yes&#34;:
                    await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine
                    break

                await channel.send( &#34;Your response must be either Yes or No \n&#34; +
                    &#34;Do you want to update the preferred time range for this event type? (Yes/no)&#34;
                    )
        else:
            # When user enters new event type
            await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine

    else:
        # When there are no existing event types
        await channel.send(
            &#34;Seems like you do not have any existing event types. What should be the name of the new type?:\n&#34;
        )
        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        event_msg = event_msg.content  # Strips message to just the text the user entered
        await create_event_type(ctx, client, event_msg)  # Running event_type creation subroutine

    event_array.append(event_msg)

    await channel.send(
        &#34;What is the location of the event?(Type None for no location/online)&#34;
    )
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    event_array.append(event_msg)
    dest=event_msg
    print(dest)
    if event_msg !=&#39;None&#39;:
        await channel.send(
            &#34;Do you want to block travel time for this event?(Yes/No)&#34;
        )
        event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
        travel_flag = event_msg.content
        if travel_flag ==&#39;Yes&#39;:
            await channel.send(
                &#34;Enter exact string out of following modes:[DRIVING, WALKING, BICYCLING, TRANSIT])&#34;
            )
            event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
            mode = event_msg.content
            
            await channel.send(
                &#34;Enter source address&#34;
            )
            event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
            src = event_msg.content
            travel_time=get_distance(dest,src,mode)
            end=event_array[1]
            strt=(end-timedelta(seconds=travel_time))
            
            
            current = Event(&#34;Travel&#34;,strt, end, &#34;1&#34;, &#34;&#34;, &#34;&#34;, &#34;&#34;)
            await channel.send(&#34;Your Travel event was successfully created!&#34;)
            add_event_to_file(str(ctx.author.id), current)
            
            
    await channel.send(&#34;Any additional description you want me to add about the event? If not, enter &#39;done&#39;&#34;)
    event_msg = await client.wait_for(&#34;message&#34;, check=check)  # Waits for user input
    event_msg = event_msg.content  # Strips message to just the text the user entered
    if event_msg.lower() == &#34;done&#34;:
        event_array.append(&#34;&#34;)
    else:
        event_array.append(event_msg)
    



    # Tries to create an Event object from the user input
    try:
        current = Event(event_array[0], event_array[1], event_array[2], event_array[3], event_array[4], event_array[6],event_array[5])

        &#34;&#34;&#34;
        Check if the command is called in the DM or in general channel
        If DMed then add event to the author
        else ask mentions and save the event to the corresponding author ids
        &#34;&#34;&#34;
        
        if isinstance(ctx.channel, discord.channel.DMChannel):
            add_event_to_file(str(ctx.author.id), current)

        else:
            await channel.send(&#34;Mention people&#34;)
            users = []
            mentioned_members = await client.wait_for(&#34;message&#34;, check=check)
            mentioned_members = mentioned_members.content

            for member in mentioned_members.split():
                member_id = member[2:-1]
                print(&#34;this is&#34;, member_id)
                user = discord.utils.find(lambda m : m.id == int(member_id), channel.members)
                users.append(user.id)
            print(users)

            for i in users:
                add_event_to_file(str(i), current)

        await channel.send(&#34;Your event was successfully created!&#34;)
    except Exception as e:
        # Outputs an error message if the event could not be created
        print(e)
        TracebackType.print_exc()
        await channel.send(
            &#34;There was an error creating your event. Make sure your formatting is correct and try creating the event again.&#34;
        )</code></pre>
</details>
</dd>
<dt id="src.functionality.AddEvent.check_complete"><code class="name flex">
<span>def <span class="ident">check_complete</span></span>(<span>start, start_date, end, end_date, array)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="function">Function</h2>
<p>check_complete</p>
<h2 id="description">Description</h2>
<p>Boolean function to check if both the date objects are created</p>
<h2 id="input">Input</h2>
<p>start_date - start date
end_date - end date</p>
<h2 id="output">Output</h2>
<ul>
<li>True if both the date objects are created else False</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_complete(start, start_date, end, end_date, array):
    &#34;&#34;&#34;
    Function:
        check_complete
    Description:
        Boolean function to check if both the date objects are created
    Input:
        start_date - start date
        end_date - end date
    Output:
        - True if both the date objects are created else False
    &#34;&#34;&#34;
    if start and end:
        print(&#34;Both date objects created&#34;)
        array.append(start_date)
        array.append(end_date)
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.functionality" href="index.html">src.functionality</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.functionality.AddEvent.add_event" href="#src.functionality.AddEvent.add_event">add_event</a></code></li>
<li><code><a title="src.functionality.AddEvent.check_complete" href="#src.functionality.AddEvent.check_complete">check_complete</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>